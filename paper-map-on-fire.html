<link rel="import" href="../firebase-element/firebase-element.html">
<link rel="import" href="../google-map/google-map.html">
<link rel="import" href="../google-map/google-map-search.html">
<link rel="import" href="../app-globals/app-globals.html">
<link rel="import" href="../paper-card/paper-card.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../core-input/core-input.html">
<link rel="import" href="../core-icons/core-icons.html">
<link rel="import" href="../paper-fab/paper-fab.html">

<polymer-element id="paperMapOnFire" name="paper-map-on-fire" attributes="url location centering">
<template>
<link rel="stylesheet" href="paper-map-on-fire.css">

<!-- Firebase Element -->
<firebase-element location="{{ url }}" data="{{ data }}" keys="{{ keys }}" id="paperMapOnFireBase"></firebase-element>
<app-globals id="globals" pinsinmap="{{keys|geofilter(data)|justOfTypes(data,filters)}}" filters={{filters}}></app-globals> 
<div>
  <div id="map_space"> 
    <google-map     latitude="{{ $.google_map_search.result.latitude }}" longitude="{{ $.google_map_search.result.longitude }}" id="google_map">
      <template repeat="{{x in $.globals.values.pinsinmap}}">
        <google-map-marker longitude="{{ data[x].LatLng|LatLngTolongitude }}" latitude="{{ data[x].LatLng|LatLngTolatitude }}" title="{{data[x].value}}"></google-map-marker>
      </template>
    </google-map>
    <google-map-search map="{{ $.google_map.map }}" query="{{ location }}" id="google_map_search"></google-map-search>
          
  </div> 
  <div id="filters">
    <!-- 
    <template repeat="{{key in keys | justTypes(data)}}">
      <paper-button on-tap="{{setFilter}}">{{data[key].type}}</paper-button>
    </template>
    -->
    <template repeat="{{x in $.globals.values.pinsinmap | justProperties(data,'facilities')}}">
      <paper-button raised?="ifFiltered" on-tap="{{setFilter}}" filter="facilities" title="{{x.name}}">
        {{x.name}}<mini-badge>{{x.num }}</mini-badge>
      </paper-button>
    </template>
  </div>
  <div id="cards"> 
    <input placeholder="text input" id="core_input" value="{{ location }}"></input>

    <template repeat="{{x in $.globals.values.pinsinmap}}">
     <paper-card flex heading="{{data[x].value}}">
      <div id="cardtitle" style="width:180px">
        <h3> 
          <a href="{{data[x].url}}"> {{data[x].value}} </a>
        </h3>
      </div>
      <div id="cardimg" style="position:absolute;left:180px;top:0px">
        <img src="https://sdyrcs.cloudimage.io/s/crop/120x120/{{ data[x].image }}">
      </div>
     </paper-card>
    </template>

  </div>
</div>
</template>
<script>
  //
  //globals
  //
  var map;
  var pinsinmap;
  var area = {
    reset: function() { console.log('reset');
      area.bounds = new google.maps.LatLngBounds();
    },
    bounds: {},
    contains_str_latlng: function(LatLng) { console.log('contains_str_latlng');
      if (LatLng !== undefined) {
        return area.contains(+LatLng.split(',')[0], +LatLng.split(',')[1]);
        } else {
        return false;
      }
    },
    contains: function(lat, lng) { console.log('contains');
      var point = new google.maps.LatLng(lat, lng);
      return area.bounds.contains(point);
    },
    extend: function(lat, lng) { console.log('extend');
      var point = new google.maps.LatLng(lat, lng);
      this.bounds.extend(point);
    }
  };
  var initialize = true;
  var setmap = function() {
    var d = document.querySelectorAll("html /deep/ #google_map");
    map = d[0].map;
    //map.panControl = false;
    area.bounds = map.getBounds();
    google.maps.event.addListener(map, 'idle', function() {
      area.bounds = map.getBounds();
      var app = document.querySelectorAll("html /deep/ #paperMapOnFire")[0];
      var data = app.data;
      var keys = app.keys;
      // app.pinsinmap = 
      app.geofilter(keys,data);
    });
    initialize = false;
  };

  function getArray(value,data,theArray) {
    var is = [];
    if (hasOwnProperty(data[value],theArray)) {
      is = data[value][theArray];
    }
    return is;
  }  
  function ofCat (value, data, cat) {
    if (data[value]["cat"] !== cat) {
      return false;
    } else {
      return true;
    }
  }
  function firstType (value,data) {
    var isFirst = false;
    for(var index in data) { 
      var attr = data[index].type; 
      if (data[value].type === attr) {
        if (isFirst) {
          return false;
          } else {
          isFirst = true;
        }
        if (index === value) {
          return isFirst;
        }
      }
    }
    return true;
  }  
  function ofType (value,data,type) {
    if (data[value].type !== type) {
      return false;
    } else {
      return true;
    }
  }
  function hasOwnProperty(obj, prop) {
    if (obj === null) {
      return false;
    }
    var proto = obj.__proto__ || obj.constructor.prototype;
    return (prop in obj) &&
    (!(prop in proto) || proto[prop] !== obj[prop]);
  }
  function isEmpty(obj) {
    for(var prop in obj) {
      if(obj.hasOwnProperty(prop))
      return false;
    }
    return true;
  }
  function hasTypes (data,types) {
    var has = false;
    for (var key in types) {
      if (types.hasOwnProperty(key)) {
        var obj = types[key];
        for (var prop in obj) {
          if(obj.hasOwnProperty(prop)){
            if (data.hasOwnProperty(key)) {
              if (obj[prop]) {
                if (data[key].indexOf(prop) === -1 ) {
                  return false;
                }
              }
            } else {
              return false;
            }
          }
        }
      }
    }
    return true;
  }
  Polymer({
    data: null,
    keys: null,
    filters:{},
    ifFiltered: function(e) {
      debugger;
      if (hasOwnProperty(e.currentTarget.attributes,"filter")){
        if (hasOwnProperty(e.currentTarget,"raised")) {
          if (hasOwnProperty(this.filters,e.currentTarget.attributes["filter"].value)) {
            if (hasOwnProperty(this.filters[e.currentTarget.attributes["filter"].value], e.currentTarget.attributes["title"].value)) {
              e.currentTarget.raised = !this.filters[e.currentTarget.attributes["filter"].value][e.currentTarget.attributes["title"].value];
            }
          }
        }
      }
    },
    setFilter: function(e) {
      if (hasOwnProperty(e.currentTarget.attributes,"filter")){
        if (hasOwnProperty(e.currentTarget.attributes.filter, "value")) {
          if (hasOwnProperty(this.filters, e.currentTarget.attributes.filter.value)) {
            this.filters[e.currentTarget.attributes.filter.value][e.currentTarget.attributes["title"].value] = 
            !this.filters[e.currentTarget.attributes.filter.value][e.currentTarget.attributes["title"].value];
          } else {
            this.filters[e.currentTarget.attributes.filter.value] = {};
            this.filters[e.currentTarget.attributes.filter.value][e.currentTarget.attributes["title"].value] = true;
          }
          this.$.globals.values.pinsinmap = this.geofilter(this.justOfTypes(this.keys, this.data, this.filters), this.data);
        }
      }
    },
    LatLngTolongitude: function(value) { console.log('LatLngTolongitude');
      if (value !== undefined) {
        return +value.split(',')[1];
      }
    },
    LatLngTolatitude: function(value) { console.log('LatLngTolatitude');
      if (value !== undefined) {
        return +value.split(',')[0];
      }
    },
    geofilter: function(value,data) { console.log('geofilter');
      if (data !== null && value !== null) {
        if (initialize) { setmap() };
        //initialize();
        var check = area.contains_str_latlng;
        var output=[];
        value.forEach(function(key) {
          if (check(data[key].LatLng)) {
            output.push(key);
          }
        });
        var d = document.querySelectorAll("html /deep/ #globals");
        this.$.globals.values.pinsinmap = output;
        return output;
      }
    },
    justProperties: function(value,data,properties){ console.log('justProperties');
      var output = [];
      var output_num = [];
      if (value !== undefined && value !== null ) {
        value.forEach(function(entry) {
          getArray(entry, data, properties).forEach(function(entryA) {
            if (output.indexOf(entryA) === -1){
              output.push(entryA); 
              output_num.push( 1 );
            } else {
              output_num[output.indexOf(entryA)]++;
            }
          });
        });
      }
      var result = [];
      for (var i = 0, l = output.length; i < l; i++) {
        result[i] = {name:output[i],num:output_num[i]};
      }
      return result;
    },
    justCardsOfCats: function(value,data,type){ // needs work
      console.log('justCardsOfCats');
      if (type === 'All') {
        return value;
      } else {
        var output = [];
        value.forEach(function(entry) {
          if (ofCat(entry,data,type)) {
            output.push(entry); 
          }
        });
        return output;
      }
    },
    justOfTypes: function(value,data,types){ console.log('justOfTypes');
      if (value === null) {
        return null;
      }
      if (isEmpty(types)) {
        return value;
        } else {
        var output = [];
        value.forEach(function(entry) {
          if (hasTypes(data[entry],types)) {
            output.push(entry); 
          }
        });
        return output;
      }
    },
    ready: function() { console.log('ready');
      console.log('Pins: ' + this.$.globals.values.pinsinmap);
      pinsinmap = this.$.globals.values.pinsinmap;
    }
  });
</script>
</polymer-element>
